---
title: ""
description: ""
pubDate: "2025/11/25"
# updatedDate: "2025/10/13"
# heroImage: "/2025-11-25-high-thread-issue.avif"
---

## 目次

## 3行まとめ
1. Vitestを使っていたらハイスペックなPCのときに顕在化しやすい問題（同じテストコードなのにFailする環境がある）に遭遇しました
2. 原因はどうやらOSのファイルディスクリプタ上限
3. 解決策の1つは名前付きインポートをデフォルトインポートに変更することでした

## 背景
職業訓練校内で実行した際はPassしたテストが、自宅のPCだとFailしました（[該当コミット](https://github.com/hndyu/yourmix/commit/123456789test)）。

![ALT](/path)

## 原因
エラー内容はEMFILE: too many open files。初めて見るエラーだったのでとりあえず検索したところ、[Vitest公式リポジトリのIssue](https://github.com/vitest-dev/vitest/issues/3576)が最初に現れました。

Issueには高スレッド環境でのみ問題が起きるとあります。これは自宅でのみFailした理由の説明になりえます。以下の通り、PC環境に違いがあるからです。

- 職業訓練校のPC：i7-9700（8コア8スレッド）
- 自宅のPC：i5-13700（8コア16スレッド？）

AIの力も借りつつ調べたところ、[Vitestは複数のプロセスでテストを実行する](https://vitest.dev/guide/features.html#threads)ため、PCのスレッド数やテストコードの内容によってはファイルディスクリプタの上限に到達してしまうようでした。特にlodash-esや@mui/icons-materialなど、モジュール数が多いパッケージを採用していると起こりやすいようです。

つまり本質的にはVitestが原因ではなく、他のテストランナーでも同様の問題が発生する可能性があります。場合によっては低スレッド数のPCでも再現できるかもしれません。

## 対処
### 対処法その1
前述のIssueには以下のようなコメントがあります。

>[After going through the code base and converting every named import to a default import from the relevant file, the issue was resolved.](https://github.com/vitest-dev/vitest/issues/3576#issuecomment-2631819571)

私も名前付きインポートを使用していたので、デフォルトのインポートで解決できるか試してみました（[該当コミット](https://github.com/hndyu/yourmix/commit/123456789test)）。結果は以下です。

![ALT](/path)

確かにテストにPassできました！

### 対処法その2
Vitestを[並列処理を行わない設定](https://vitest.dev/config/fileparallelism.html)にすることでもPassすることを確認しました。

![ALT](/path)

とはいえテストでは並列処理を行うことが公式で推奨されています。今回はデフォルトのインポートで解決できたこともあり、こちらのコンフィグ変更は検証のみ行いコミットしませんでした。

## Copilot（GPT-5）の見解（参考）
なぜ高スレッド環境で問題が起きるのかを質問した際の回答を記録として残しておきます。

### 🔍 背景
- Node.jsやOSには「同時に開けるファイル数（ファイルディスクリプタ）」の上限があります。
- Vitestはテストを並列実行するために**スレッドごとに大量のファイルを読み込む**（モジュールや依存関係を開く）。
- スレッド数が増えると、同時に開かれるファイル数も比例して増える。

### 🧩 なぜ高スレッド環境で問題になるのか
- **低スレッド環境**
  - 例えば4〜8スレッド程度なら、同時に開くファイル数は上限に届かない。
  - OSが許容する範囲で処理できるためエラーは出にくい。
- **高スレッド環境（例：32スレッド）**
  - 各スレッドが同時に数百〜数千ファイルを開こうとする。
  - 合計するとOSのファイルディスクリプタ上限を超えてしまう。
  - 結果としてEMFILE（Too many open files）が発生。

### 💡 例えで説明
- **低スレッド環境**は「小さな図書館で数人が本を借りる」イメージ。棚の本は十分あるので問題なし。
- **高スレッド環境**は「大人数が一斉に本を借りに来る」イメージ。貸し出しカウンター（ファイルディスクリプタ）が足りなくなり「もう貸せません」とエラーになる。

### ✅ まとめ
- 問題の本質は「**スレッド数が増えると同時に開くファイル数が爆発的に増える**」こと。
- OSのファイルディスクリプタ上限を超えるため、高スレッド環境でのみ顕著にエラーが出る。
- 回避策はスレッド数を制限するか、インポート方法を工夫して「同時に開くファイル数」を減らすこと。
